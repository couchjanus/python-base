# Сервер TCP srv01_socket.py

# Суть TCP-соединения: одна программа устанавливает соединение с другой, и они обмениваются данными, причём их потери не происходит. После завершения работы соединение должно быть закрыто.

# Для работы с сокетами нужно импортировать модуль socket:
import socket
# Код модуля socket является объектно-ориентированной-оберткой вокрут набора системных вызовов для работе с сокетами. 

# Его можно представить себе, как:

# class socket:  # имя класса с маленькой буквы
#     def __init__(domain, type, proto):
#         self._fd = system_socket(domain, type, proto)

#     def write(data):
#         # вместо write используется send
#         system_write(self._fd, data)

#     def fileno():
#         return self._fd

# для инициализации сокета введен специальный одноименный системный вызов socket(). 

# создать сокет:
# server_sock = socket.socket()

# print(type(server_sock))           # <class 'socket.socket'>

print(socket.AF_INET)  # AddressFamily.AF_INET
print(socket.SOCK_STREAM)  # SocketKind.SOCK_STREAM

server_sock = socket.socket(
    socket.AF_INET,      # задамем семейство протоколов 'Интернет' (INET)
    socket.SOCK_STREAM,  # задаем тип передачи данных 'потоковый' (TCP)
    proto=0)             # выбираем протокол 'по умолчанию' для TCP, т.е. IP

# доступ к целочисленному файловому дескриптору можно получить с помощью:
print(server_sock.fileno())  # int
print(server_sock.proto)  # 0

# Для создания сервера нужно связать сокет с одним или всеми из имеющихся у компьютера хостов (IP-адресов) и каким-либо свободным портом. 

# на серверной машине может быть несколько сетевых адаптеров, нам необходимо привязать созданный сокет к одному из них:
server_sock.bind(('127.0.0.1', 53000))  # чтобы привязать сразу ко всем, можно использовать ''

print(server_sock.laddr)  # 0

# Если не указать хост или указать "0.0.0.0", сокет будет прослушивать все хосты. Если указать "127.0.0.1", то подключиться можно будет только с этого же компьютера.

# Вызов bind() заставляет нас указать не только IP адрес, но и порт, на котором сервер будет ожидать (слушать) подключения клиентов.
# функция bind принимает массив, содержащий два элемента: хост и порт.

# параметр backlog
# взаимодействие по сети происходит с помощью отправки пакетов, а TCP требует установления соединения, т.е. обмена между клиентом и сервером несколькими служебными пакетами, не содержащими реальных бизнес-данных. Каждое TCP соединение обладает состоянием. 

# их можно представить себе так:
# СОЕДИНЕНИЕ УСТАНАВЛИВАЕТСЯ -> УСТАНОВЛЕНО -> СОЕДИНЕНИЕ ЗАКРЫВАЕТСЯ

# параметр backlog определяет размер очереди для установленных соединений. Пока количество подключенных клиентов меньше, чем этот параметр, операционная система будет автоматически принимать входящие соединения на серверный сокет и помещать их в очередь. Как только количество установленных соединений в очереди достигнет значения backlog, новые соединения приниматься не будут. В зависимости от реализации, OC может явно отклонять новые подключения или просто их игнорировать, давая возможность им дождаться освобождения места в очереди.

# необходимо явно перевести сокет в состояние ожидания подключения, сообщив об этом операционной системе:

# функция listen принимает в качестве аргумента максимальное число соединений, которые будут находиться в очереди соединений до вызова функции accept; она не ограничивает максимальное число активных соединений в целом.

server_sock.listen(10)  # 10 - это размер очереди входящих подключений (backlog)

# После этого вызова операционная система готова принимать подключения от клиентов на этом сокете
